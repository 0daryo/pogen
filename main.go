package main

import (
	"bytes"
	"flag"
	"go/format"
	"html/template"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strings"

	"github.com/emicklei/proto"
)

var (
	patternToRegexp map[string]string = make(map[string]string)
	output                            = flag.String("o", "output.go", "output file")
	pkg                               = flag.String("p", "main", "package name")
	protoDir                          = flag.String("d", "proto/service", "proto directory name")
)

const (
	testPathVar = "aA1_-"
)

type patternRegexp struct {
	Pattern      string
	RegexPattern string
	TestPath     string
}

func main() {
	flag.Parse()
	var files []string
	root := *protoDir
	err := filepath.Walk(root, func(path string, info os.FileInfo, err error) error {
		isDir, err := isDir(path)
		if err != nil {
			return err
		}
		if isDir {
			return nil
		}
		files = append(files, path)
		return nil
	})
	if err != nil {
		panic(err)
	}
	for _, f := range files {
		reader, err := os.Open(f)
		if err != nil {
			panic(err)
		}
		defer reader.Close()

		parser := proto.NewParser(reader)
		definition, err := parser.Parse()
		if err != nil {
			panic(err)
		}
		proto.Walk(definition,
			proto.WithRPC(handleRPC),
		)
	}

	tp := struct {
		Pkg           string
		PatternRegexp []patternRegexp
	}{
		Pkg: *pkg,
		PatternRegexp: func() []patternRegexp {
			ret := make([]patternRegexp, 0)
			for k, v := range patternToRegexp {
				ret = append(ret, patternRegexp{
					Pattern:      k,
					RegexPattern: v,
					TestPath:     r.ReplaceAllString(k, testPathVar),
				})
			}
			sort.SliceStable(ret, func(i, j int) bool {
				return ret[i].Pattern < ret[j].Pattern
			})
			return ret
		}(),
	}

	// generate code
	{
		if err := deleteIfExist(*output); err != nil {
			panic(err)
		}
		file, err := os.Create(*output)
		if err != nil {
			panic(err)
		}
		b := new(bytes.Buffer)
		if err := tpl.Execute(b, tp); err != nil {
			panic(err)
		}
		formatted, err := format.Source(b.Bytes())
		if err != nil {
			panic(err)
		}
		file.Write(formatted)
	}
	// generate test code
	{
		testPath := strings.TrimSuffix(*output, filepath.Ext(*output)) + "_test.go"
		if err := deleteIfExist(testPath); err != nil {
			panic(err)
		}
		file, err := os.Create(testPath)
		if err != nil {
			panic(err)
		}

		b := new(bytes.Buffer)
		if err := testTpl.Execute(b, tp); err != nil {
			panic(err)
		}
		formatted, err := format.Source(b.Bytes())
		if err != nil {
			panic(err)
		}
		file.Write(formatted)
	}
}

var r = regexp.MustCompile("{[a-zA-Z0-9_]*}")

func handleRPC(s *proto.RPC) {
	for _, o := range s.Options {
		get, ok := o.Constant.Map["get"]
		if ok {
			pattern := "^" + r.ReplaceAllString(get.Source, "[-a-zA-Z0-9_]*") + "$"
			patternToRegexp[get.Source] = pattern
		}
		post, ok := o.Constant.Map["post"]
		if ok {
			pattern := "^" + r.ReplaceAllString(post.Source, "[-a-zA-Z0-9_]*") + "$"
			patternToRegexp[post.Source] = pattern
		}
		put, ok := o.Constant.Map["put"]
		if ok {
			pattern := "^" + r.ReplaceAllString(put.Source, "[-a-zA-Z0-9_]*") + "$"
			patternToRegexp[put.Source] = pattern
		}
		delete, ok := o.Constant.Map["delete"]
		if ok {
			pattern := "^" + r.ReplaceAllString(delete.Source, "[-a-zA-Z0-9_]*") + "$"
			patternToRegexp[delete.Source] = pattern
		}
	}
}

func isDir(name string) (bool, error) {
	fi, err := os.Stat(name)
	if err != nil {
		return false, err
	}
	switch mode := fi.Mode(); {
	case mode.IsDir():
		return true, nil
	default:
		return false, nil
	}
}

var tpl = template.Must(template.New("code").Parse(text))
var testTpl = template.Must(template.New("test").Parse(testText))

const text = `
// Code generated by pogen. DO NOT EDIT.
package {{ .Pkg }}

import (
	"regexp"
)
// nolint
var pathToRegexp = map[string]*regexp.Regexp{
	{{range $pr := .PatternRegexp}}	"{{$pr.Pattern}}": regexp.MustCompile("{{$pr.RegexPattern}}"),
	{{end}}
}

func Pattern(path string)(pattern string, found bool){
	for k,v := range pathToRegexp{
		if v.MatchString(path){
			return k, true
		}
	}
	return "", false
}
`

const testText = `
// Code generated by pogen. DO NOT EDIT.
package {{ .Pkg }}

import "testing"

func TestPattern(t *testing.T) {
	type args struct {
		path string
	}
	tests := []struct {
		name        string
		args        args
		wantPattern string
		wantFound   bool
	}{
		{{range $pr := .PatternRegexp}}{
			name: "{{$pr.Pattern}}",
			args: args{
				path: "{{$pr.TestPath}}",
			},
			wantPattern:  "{{$pr.Pattern}}",
			wantFound:   true,
		},
		{{ end }}{
			name: "nopass",
			args: args{
				path: "nopassnopass",
			},
			wantPattern: "",
			wantFound:   false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			gotPattern, gotFound := Pattern(tt.args.path)
			if gotPattern != tt.wantPattern {
				t.Errorf("Pattern() gotPattern = %v, want %v", gotPattern, tt.wantPattern)
			}
			if gotFound != tt.wantFound {
				t.Errorf("Pattern() gotFound = %v, want %v", gotFound, tt.wantFound)
			}
		})
	}
}
`

func deleteIfExist(path string) error {
	_, err := os.Stat(path)
	if os.IsNotExist(err) {
		return nil
	}
	return os.Remove(path)
}
