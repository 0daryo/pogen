package main

import (
	"bytes"
	"flag"
	"go/format"
	"html/template"
	"os"
	"path/filepath"
	"regexp"

	"github.com/emicklei/proto"
)

var (
	patternToRegexp map[string]string = make(map[string]string)
	output                            = flag.String("o", "output.go", "output file")
	pkg                               = flag.String("p", "main", "package name")
	protoDir                          = flag.String("d", "proto/service", "proto directory name")
)

type patternRegexp struct {
	Pattern      string
	RegexPattern string
}

func main() {
	flag.Parse()
	var files []string
	root := *protoDir
	err := filepath.Walk(root, func(path string, info os.FileInfo, err error) error {
		isDir, err := isDir(path)
		if err != nil {
			return err
		}
		if isDir {
			return nil
		}
		files = append(files, path)
		return nil
	})
	if err != nil {
		panic(err)
	}
	for _, f := range files {
		reader, err := os.Open(f)
		if err != nil {
			panic(err)
		}
		defer reader.Close()

		parser := proto.NewParser(reader)
		definition, err := parser.Parse()
		if err != nil {
			panic(err)
		}
		proto.Walk(definition,
			proto.WithRPC(handleRPC),
		)
	}
	if err := deleteIfExist(*output); err != nil {
		panic(err)
	}
	file, err := os.Create(*output)
	if err != nil {
		panic(err)
	}
	tp := struct {
		Pkg           string
		PatternRegexp []patternRegexp
	}{
		Pkg: *pkg,
		PatternRegexp: func() []patternRegexp {
			ret := make([]patternRegexp, 0)
			for k, v := range patternToRegexp {
				ret = append(ret, patternRegexp{
					Pattern:      k,
					RegexPattern: v,
				})
			}
			return ret
		}(),
	}
	b := new(bytes.Buffer)
	if err := tpl.Execute(b, tp); err != nil {
		panic(err)
	}
	formatted, err := format.Source(b.Bytes())
	if err != nil {
		panic(err)
	}
	file.Write(formatted)
}

var r = regexp.MustCompile("{.*}")

func handleRPC(s *proto.RPC) {
	for _, o := range s.Options {
		get, ok := o.Constant.Map["get"]
		if ok {
			pattern := "^" + r.ReplaceAllString(get.Source, "[a-zA-Z0-9]*") + "$"
			patternToRegexp[get.Source] = pattern
		}
		post, ok := o.Constant.Map["post"]
		if ok {
			pattern := "^" + r.ReplaceAllString(post.Source, "[a-zA-Z0-9]*") + "$"
			patternToRegexp[post.Source] = pattern
		}
		put, ok := o.Constant.Map["put"]
		if ok {
			pattern := "^" + r.ReplaceAllString(put.Source, "[a-zA-Z0-9]*") + "$"
			patternToRegexp[put.Source] = pattern
		}
	}
}

func isDir(name string) (bool, error) {
	fi, err := os.Stat(name)
	if err != nil {
		return false, err
	}
	switch mode := fi.Mode(); {
	case mode.IsDir():
		return true, nil
	default:
		return false, nil
	}
}

var tpl = template.Must(template.New("maps").Parse(text))

const text = `
// Code generated by pogen. DO NOT EDIT.
package {{ .Pkg }}

import (
	"regexp"
)
// nolint
var pathToRegexp = map[string]*regexp.Regexp{
	{{range $pr := .PatternRegexp}}	"{{$pr.Pattern}}": regexp.MustCompile("{{$pr.RegexPattern}}"),
	{{end}}
}

func Pattern(path string)(pattern string, found bool){
	for k,v := range pathToRegexp{
		if v.MatchString(path){
			return k, true
		}
	}
	return "", false
}
`

func deleteIfExist(path string) error {
	_, err := os.Stat(path)
	if os.IsNotExist(err) {
		return nil
	}
	return os.Remove(path)
}
